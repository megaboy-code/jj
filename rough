// ===============================================================
// ðŸ“ŠðŸ”” ANALYSIS_ALERTS.JS - PROFESSIONAL SPEEDOMETER VERSION
// ===============================================================

// Analysis state
let currentAnalysis = {};
let activeAlerts = [];
let alertSettings = {
    rsiAlerts: true,
    priceAlerts: false,
    volumeAlerts: true,
    momentumAlerts: true
};

// Gauge state with placeholder values
let gaugeValues = {
    momentum: -45,    // Bearish momentum
    volatility: 68,   // High volatility
    strength: 82,     // Strong trend
    risk: 35          // Low risk
};

// Professional Gauge Configuration
const GAUGE_CONFIGS = {
    momentum: {
        minValue: -100,
        maxValue: 100,
        minAngle: -135,
        maxAngle: 135,
        thresholds: [-100, -50, -20, 20, 50, 100],
        labels: ['Strong Bear', 'Bearish', 'Slight Bear', 'Slight Bull', 'Bullish', 'Strong Bull'],
        colors: ['#DC2626', '#EF4444', '#F59E0B', '#22C55E', '#16A34A', '#15803D'],
        classes: ['bearish', 'bearish', 'neutral', 'neutral', 'bullish', 'bullish']
    },
    volatility: {
        minValue: 0,
        maxValue: 100,
        minAngle: -135,
        maxAngle: 135,
        thresholds: [0, 20, 40, 60, 80, 100],
        labels: ['Very Low', 'Low', 'Medium', 'High', 'Very High', 'Extreme'],
        colors: ['#00D394', '#22C55E', '#EAB308', '#F97316', '#EF4444', '#DC2626'],
        classes: ['low', 'low', 'medium', 'high', 'high', 'high']
    },
    strength: {
        minValue: 0,
        maxValue: 100,
        minAngle: -135,
        maxAngle: 135,
        thresholds: [0, 20, 40, 60, 80, 100],
        labels: ['Very Weak', 'Weak', 'Moderate', 'Strong', 'Very Strong', 'Extreme'],
        colors: ['#DC2626', '#EF4444', '#EAB308', '#22C55E', '#00D394', '#00B378'],
        classes: ['weak', 'weak', 'moderate', 'strong', 'strong', 'strong']
    },
    risk: {
        minValue: 0,
        maxValue: 100,
        minAngle: -135,
        maxAngle: 135,
        thresholds: [0, 25, 50, 75, 100],
        labels: ['Very Low', 'Low', 'Medium', 'High', 'Very High'],
        colors: ['#22C55E', '#10B981', '#EAB308', '#F97316', '#EF4444', '#DC2626'],
        classes: ['low', 'low', 'medium', 'high', 'high']
    }
};

// Initialize analysis & alerts module
function initializeAnalysisAlerts() {
    console.log("ðŸ“ŠðŸ”” Enhanced Analysis & Alerts module initialized");
    loadAlertSettings();
    initializeProfessionalGauges();
    initializeEnhancedAnalysis();
    renderAnalysisSections();
    renderAlertsSections();
    
    // Mark as initialized
    const gaugesContainer = document.getElementById('gauges-container');
    if (gaugesContainer) {
        gaugesContainer.setAttribute('data-initialized', 'true');
    }
}

// ==================== PROFESSIONAL GAUGE SYSTEM ====================

// Get gauge configuration based on type and value
function getGaugeConfig(type, value) {
    const config = GAUGE_CONFIGS[type];
    if (!config) return { label: 'Unknown', class: 'neutral', color: '#9CA3AF' };

    for (let i = 0; i < config.thresholds.length - 1; i++) {
        if (value >= config.thresholds[i] && value < config.thresholds[i + 1]) {
            return {
                label: config.labels[i],
                class: config.classes[i],
                color: config.colors[i]
            };
        }
    }
    
    return {
        label: config.labels[config.labels.length - 1],
        class: config.classes[config.classes.length - 1],
        color: config.colors[config.colors.length - 1]
    };
}

// Calculate rotation angle based on value and gauge type
function calculateRotation(type, value) {
    const config = GAUGE_CONFIGS[type];
    if (!config) return -135;
    
    const range = config.maxValue - config.minValue;
    const angleRange = config.maxAngle - config.minAngle;
    return ((value - config.minValue) / range) * angleRange + config.minAngle;
}

// Generate arc fill based on gauge type and value
function generateArcFill(type, value) {
    const config = GAUGE_CONFIGS[type];
    if (!config) return 'transparent';
    
    // For momentum gauge - full arc always visible
    if (type === 'momentum') {
        return `conic-gradient(from -135deg,
            #DC2626 0deg, #EF4444 45deg, #F59E0B 90deg, 
            #22C55E 135deg, #16A34A 180deg, #15803D 225deg,
            transparent 270deg, transparent 360deg)`;
    }
    
    // For other gauges - partial fill based on value
    const fillDeg = (value / config.maxValue) * 270;
    
    if (type === 'risk') {
        return `conic-gradient(from -135deg,
            transparent 0deg,
            #22C55e 0deg, #10B981 60deg, #EAB308 120deg,
            #F97316 180deg, #EF4444 240deg, #DC2626 ${fillDeg}deg,
            transparent ${fillDeg}deg)`;
    }
    
    if (type === 'volatility') {
        return `conic-gradient(from -135deg,
            transparent 0deg,
            #00D394 0deg, #22C55E 60deg, #EAB308 120deg,
            #F97316 180deg, #EF4444 240deg, #DC2626 ${fillDeg}deg,
            transparent ${fillDeg}deg)`;
    }
    
    if (type === 'strength') {
        return `conic-gradient(from -135deg,
            transparent 0deg,
            #DC2626 0deg, #EF4444 60deg, #EAB308 120deg,
            #22C55E 180deg, #00D394 240deg, #00B378 ${fillDeg}deg,
            transparent ${fillDeg}deg)`;
    }
    
    return 'transparent';
}

// Enhanced professional gauge update function
function updateProfessionalGauge(type, value) {
    const needle = document.getElementById(`${type}-needle`);
    const scoreEl = document.getElementById(`${type}-score`);
    const labelEl = document.getElementById(`${type}-label`);
    const arcFillEl = document.getElementById(`${type}-arc`);
    const indicatorEl = document.querySelector(`#${type}-indicator`);
    const gaugeItem = document.getElementById(`${type}-gauge`);

    if (!needle || !scoreEl || !labelEl || !arcFillEl || !indicatorEl) {
        console.warn(`Gauge elements for ${type} not found`);
        return;
    }

    // Remove all state classes first
    gaugeItem.classList.remove('extreme', 'updating', 'risk-high', 'risk-medium', 'risk-low');
    labelEl.className = 'gauge-label';
    indicatorEl.className = 'gauge-indicator-dot';

    // Add updating state
    gaugeItem.classList.add('updating');

    // 1. Needle rotation
    const rotation = calculateRotation(type, value);
    needle.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

    // 2. Update score with smooth counting
    const currentValue = parseFloat(scoreEl.textContent) || 0;
    animateValue(scoreEl, currentValue, value, 800);

    // 3. Update arc fill
    arcFillEl.style.background = generateArcFill(type, value);

    // 4. Update label and indicator with CSS classes
    const gaugeConfig = getGaugeConfig(type, value);
    labelEl.textContent = gaugeConfig.label;
    labelEl.classList.add(gaugeConfig.class);
    indicatorEl.classList.add(gaugeConfig.class);

    // 5. Add extreme effects for values at boundaries
    if ((type === 'momentum' && (value >= 80 || value <= -80)) ||
        (type !== 'momentum' && (value >= 90 || value <= 10))) {
        gaugeItem.classList.add('extreme');
    }

    // 6. Special handling for risk gauge pulsing
    if (type === 'risk' && value >= 75) {
        gaugeItem.classList.add('risk-high');
    } else if (type === 'risk' && value >= 50) {
        gaugeItem.classList.add('risk-medium');
    } else if (type === 'risk' && value <= 25) {
        gaugeItem.classList.add('risk-low');
    }

    // Remove updating state after animation
    setTimeout(() => {
        gaugeItem.classList.remove('updating');
    }, 800);
}

// Smooth value counting animation
function animateValue(element, start, end, duration) {
    const startTime = performance.now();
    const change = end - start;

    function updateValue(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function for smooth counting
        const easeOut = 1 - Math.pow(1 - progress, 3);
        const currentValue = type === 'momentum' ? 
            Math.round(start + change * easeOut) : 
            Math.round(start + change * easeOut);
        
        element.textContent = currentValue;

        if (progress < 1) {
            requestAnimationFrame(updateValue);
        }
    }

    requestAnimationFrame(updateValue);
}

// Initialize gauges with placeholder values
function initializeProfessionalGauges() {
    console.log("ðŸŽ¯ Initializing professional gauges with placeholder values...");
    
    // Set initial values for all gauges with slight delay for visual effect
    setTimeout(() => {
        updateProfessionalGauge('momentum', gaugeValues.momentum);
        updateProfessionalGauge('volatility', gaugeValues.volatility);
        updateProfessionalGauge('strength', gaugeValues.strength);
        updateProfessionalGauge('risk', gaugeValues.risk);
        
        console.log("âœ… Professional gauges initialized with placeholders");
    }, 500);
}

// Update all gauges
function updateAllProfessionalGauges(values) {
    if (!values) {
        console.warn("No values provided to update gauges");
        return;
    }
    
    console.log("ðŸ”„ Updating all gauges with values:", values);
    
    // Update gauge values state
    gaugeValues = { ...gaugeValues, ...values };
    
    updateProfessionalGauge('momentum', gaugeValues.momentum);
    updateProfessionalGauge('volatility', gaugeValues.volatility);
    updateProfessionalGauge('strength', gaugeValues.strength);
    updateProfessionalGauge('risk', gaugeValues.risk);
}

// ==================== CONFLUENCE CALCULATION ENGINE ====================

// Calculate confluence from pyramid data
function calculateConfluence(pyramidData) {
    if (!pyramidData || !pyramidData.blocks) {
        console.warn("No pyramid data available for confluence calculation");
        return gaugeValues;
    }
    
    console.log("ðŸ§® Calculating market confluence...");
    
    const analysis = {
        timeframeMomentum: [],
        timeframeVolatility: [],
        indicatorConsensus: [],
        volumeAnalysis: []
    };
    
    // Analyze each timeframe block
    pyramidData.blocks.forEach(block => {
        const blockAnalysis = analyzeTimeframeBlock(block);
        analysis.timeframeMomentum.push(blockAnalysis.momentum);
        analysis.timeframeVolatility.push(blockAnalysis.volatility);
        analysis.indicatorConsensus.push(blockAnalysis.indicatorScore);
        analysis.volumeAnalysis.push(blockAnalysis.volumeStrength);
    });
    
    // Calculate gauge values
    gaugeValues.momentum = calculateMomentumConfluence(analysis.timeframeMomentum);
    gaugeValues.volatility = calculateVolatilityConfluence(analysis.timeframeVolatility);
    gaugeValues.strength = calculateStrengthConfluence(analysis);
    gaugeValues.risk = calculateRiskAssessment(analysis);
    
    console.log("ðŸ“ˆ Calculated gauge values:", gaugeValues);
    
    updateAllProfessionalGauges(gaugeValues);
    return gaugeValues;
}

// Analyze individual timeframe block
function analyzeTimeframeBlock(block) {
    const analysis = {
        momentum: 0,
        volatility: 0,
        indicatorScore: 0,
        volumeStrength: 0
    };
    
    // Momentum analysis (from block data)
    if (block.dir === 'ðŸŸ¢') analysis.momentum = 1;
    else if (block.dir === 'ðŸ”´') analysis.momentum = -1;
    
    // Volatility analysis (placeholder - would use ATR data)
    analysis.volatility = Math.random() * 100; // Replace with real ATR calculation
    
    // Indicator consensus (from momentum summary)
    analysis.indicatorScore = analyzeMomentumSummary(block.momentum_summary);
    
    // Volume strength (from volume data)
    analysis.volumeStrength = block.volume > 1000 ? 1 : 0.5;
    
    return analysis;
}

// Analyze momentum summary text
function analyzeMomentumSummary(summary) {
    if (!summary) return 50;
    
    let score = 50;
    
    // Basic sentiment analysis from summary text
    if (summary.includes('Strong') || summary.includes('++')) score += 25;
    if (summary.includes('Weak') || summary.includes('--')) score -= 25;
    if (summary.includes('ðŸŸ¢')) score += 15;
    if (summary.includes('ðŸ”´')) score -= 15;
    
    return Math.max(0, Math.min(100, score));
}

// Calculate momentum confluence
function calculateMomentumConfluence(momentumScores) {
    if (momentumScores.length === 0) return 50;
    
    // Weight recent timeframes more heavily
    const weights = [0.3, 0.25, 0.2, 0.15, 0.1]; // D1, H4, H1, M15, M5 weights
    let weightedSum = 0;
    let totalWeight = 0;
    
    momentumScores.forEach((score, index) => {
        const weight = weights[index] || 0.1;
        weightedSum += (score + 1) * 50 * weight; // Convert -1/1 to 0-100 scale
        totalWeight += weight;
    });
    
    return Math.round(weightedSum / totalWeight);
}

// Calculate volatility confluence
function calculateVolatilityConfluence(volatilityScores) {
    if (volatilityScores.length === 0) return 50;
    return Math.round(volatilityScores.reduce((a, b) => a + b, 0) / volatilityScores.length);
}

// Calculate strength confluence
function calculateStrengthConfluence(analysis) {
    const momentumStrength = gaugeValues.momentum;
    const consensusStrength = analysis.indicatorConsensus.reduce((a, b) => a + b, 0) / analysis.indicatorConsensus.length;
    const volumeStrength = analysis.volumeAnalysis.reduce((a, b) => a + b, 0) / analysis.volumeAnalysis.length * 100;
    
    // Weighted average of all strength factors
    return Math.round(
        (momentumStrength * 0.4) + 
        (consensusStrength * 0.4) + 
        (volumeStrength * 0.2)
    );
}

// Calculate risk assessment
function calculateRiskAssessment(analysis) {
    const volatilityRisk = gaugeValues.volatility > 70 ? 80 : gaugeValues.volatility > 30 ? 50 : 20;
    const momentumRisk = Math.abs(gaugeValues.momentum - 50) > 30 ? 70 : 40;
    const consensusRisk = analysis.indicatorConsensus.some(score => score < 30) ? 60 : 30;
    
    return Math.round((volatilityRisk + momentumRisk + consensusRisk) / 3);
}

// ==================== ENHANCED ANALYSIS COMPONENTS ====================

// Initialize enhanced analysis components
function initializeEnhancedAnalysis() {
    console.log("ðŸ“Š Initializing enhanced analysis components...");
    // Components are already in HTML, just ensure they're ready
}

// Update all enhanced analysis components
function updateEnhancedAnalysis(pyramidData, chartData) {
    if (!pyramidData) {
        console.warn("No pyramid data for enhanced analysis");
        return;
    }
    
    updateMultiTimeframeStrength(pyramidData);
    updateIndicatorConsensus(pyramidData);
    updateMarketStructure(chartData);
    updateTradingSetups(pyramidData, chartData);
    updateVolumeAnalysis(pyramidData);
}

// Update multi-timeframe strength bars
function updateMultiTimeframeStrength(pyramidData) {
    const container = document.getElementById('timeframe-strength-container');
    if (!container || !pyramidData.blocks) return;
    
    let strengthHTML = '';
    pyramidData.blocks.forEach((block, index) => {
        const strength = calculateTimeframeStrength(block);
        const strengthPercent = Math.round(strength * 100);
        const strengthClass = getStrengthClass(strengthPercent);
        
        strengthHTML += `
            <div class="timeframe-strength-item">
                <div class="timeframe-label">${block.tf}</div>
                <div class="strength-bar-container">
                    <div class="strength-bar">
                        <div class="strength-fill ${strengthClass}" style="width: ${strengthPercent}%"></div>
                    </div>
                    <div class="strength-value ${strengthClass}">${strengthPercent}%</div>
                </div>
                <div class="timeframe-direction ${block.dir === 'ðŸŸ¢' ? 'bullish' : 'bearish'}">
                    ${block.dir}
                </div>
            </div>
        `;
    });
    
    container.innerHTML = strengthHTML;
}

// Update indicator consensus
function updateIndicatorConsensus(pyramidData) {
    const consensus = calculateIndicatorConsensus(pyramidData);
    
    // Update trend consensus
    const trendFill = document.getElementById('trend-consensus-fill');
    const trendValue = document.getElementById('trend-consensus-value');
    if (trendFill && trendValue) {
        trendFill.style.width = consensus.trend + '%';
        trendValue.textContent = consensus.trend + '%';
    }
    
    // Update momentum consensus
    const momentumFill = document.getElementById('momentum-consensus-fill');
    const momentumValue = document.getElementById('momentum-consensus-value');
    if (momentumFill && momentumValue) {
        momentumFill.style.width = consensus.momentum + '%';
        momentumValue.textContent = consensus.momentum + '%';
    }
    
    // Update volatility consensus
    const volatilityFill = document.getElementById('volatility-consensus-fill');
    const volatilityValue = document.getElementById('volatility-consensus-value');
    if (volatilityFill && volatilityValue) {
        volatilityFill.style.width = consensus.volatility + '%';
        volatilityValue.textContent = consensus.volatility + '%';
    }
    
    // Update consensus summary
    const summaryElement = document.getElementById('consensus-summary');
    if (summaryElement) {
        const overallConsensus = Math.round((consensus.trend + consensus.momentum + consensus.volatility) / 3);
        const consensusClass = getConsensusClass(overallConsensus);
        summaryElement.innerHTML = `
            <div class="consensus-status ${consensusClass}">
                Overall Consensus: ${overallConsensus}% - ${getConsensusText(overallConsensus)}
            </div>
        `;
    }
}

// Update market structure
function updateMarketStructure(chartData) {
    const structure = analyzeMarketStructure(chartData);
    
    // Update resistance levels
    const resistanceElement = document.getElementById('resistance-levels');
    if (resistanceElement) {
        resistanceElement.innerHTML = structure.resistanceLevels.map(level => 
            `<div class="level-item resistance">${level.toFixed(5)}</div>`
        ).join('');
    }
    
    // Update support levels
    const supportElement = document.getElementById('support-levels');
    if (supportElement) {
        supportElement.innerHTML = structure.supportLevels.map(level => 
            `<div class="level-item support">${level.toFixed(5)}</div>`
        ).join('');
    }
    
    // Update trend information
    const primaryTrend = document.getElementById('primary-trend');
    const trendStrengthFill = document.getElementById('trend-strength-fill');
    
    if (primaryTrend) {
        primaryTrend.textContent = structure.primaryTrend;
        primaryTrend.className = `trend-value ${structure.primaryTrend.toLowerCase()}`;
    }
    
    if (trendStrengthFill) {
        trendStrengthFill.style.width = structure.trendStrength + '%';
    }
}

// Update trading setups
function updateTradingSetups(pyramidData, chartData) {
    const setups = generateTradingSetups(pyramidData, chartData);
    const container = document.getElementById('setup-cards');
    if (!container) return;
    
    if (setups.length === 0) {
        container.innerHTML = '<div class="no-setups">No high-probability setups detected</div>';
        return;
    }
    
    container.innerHTML = setups.map(setup => `
        <div class="setup-card ${setup.direction}">
            <div class="setup-header">
                <span class="setup-type">${setup.type}</span>
                <span class="setup-confidence ${getConfidenceClass(setup.confidence)}">
                    ${setup.confidence}%
                </span>
            </div>
            <div class="setup-details">
                <div class="setup-direction ${setup.direction}">${setup.direction.toUpperCase()}</div>
                <div class="setup-metrics">
                    <div class="setup-metric">
                        <span>R:R</span>
                        <span>${setup.riskReward}</span>
                    </div>
                    <div class="setup-metric">
                        <span>Stop Loss</span>
                        <span>${setup.stopLoss}</span>
                    </div>
                    <div class="setup-metric">
                        <span>Target</span>
                        <span>${setup.target}</span>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
}

// Update volume analysis
function updateVolumeAnalysis(pyramidData) {
    const volumeAnalysis = analyzeVolume(pyramidData);
    
    // Update volume metrics
    const volumeTrend = document.getElementById('volume-trend');
    const volumeVsAvg = document.getElementById('volume-vs-avg');
    const volumeConfirmation = document.getElementById('volume-confirmation');
    
    if (volumeTrend) {
        volumeTrend.textContent = volumeAnalysis.trend;
        volumeTrend.className = `volume-value ${volumeAnalysis.trend.toLowerCase()}`;
    }
    
    if (volumeVsAvg) {
        volumeVsAvg.textContent = volumeAnalysis.vsAverage;
    }
    
    if (volumeConfirmation) {
        volumeConfirmation.textContent = volumeAnalysis.confirmation;
        volumeConfirmation.className = `volume-value ${volumeAnalysis.confirmation.toLowerCase()}`;
    }
    
    // Update volume bars
    const volumeD1 = document.getElementById('volume-d1');
    const volumeH4 = document.getElementById('volume-h4');
    const volumeH1 = document.getElementById('volume-h1');
    const volumeM15 = document.getElementById('volume-m15');
    
    if (volumeD1) volumeD1.style.height = volumeAnalysis.timeframes.D1 + '%';
    if (volumeH4) volumeH4.style.height = volumeAnalysis.timeframes.H4 + '%';
    if (volumeH1) volumeH1.style.height = volumeAnalysis.timeframes.H1 + '%';
    if (volumeM15) volumeM15.style.height = volumeAnalysis.timeframes.M15 + '%';
}

// ==================== ANALYSIS CALCULATIONS ====================

// Calculate timeframe strength
function calculateTimeframeStrength(block) {
    // Simple strength calculation based on momentum summary
    let strength = 0.5; // Default neutral
    
    if (block.momentum_summary) {
        if (block.momentum_summary.includes('Strong')) strength = 0.8;
        else if (block.momentum_summary.includes('Weak')) strength = 0.3;
        
        if (block.dir === 'ðŸŸ¢') strength += 0.1;
        else if (block.dir === 'ðŸ”´') strength -= 0.1;
    }
    
    return Math.max(0, Math.min(1, strength));
}

// Calculate indicator consensus
function calculateIndicatorConsensus(pyramidData) {
    // Simplified consensus calculation
    return {
        trend: Math.round(70 + Math.random() * 20), // Would use real indicator data
        momentum: Math.round(60 + Math.random() * 30),
        volatility: Math.round(50 + Math.random() * 40)
    };
}

// Analyze market structure (placeholder - would use real chart data)
function analyzeMarketStructure(chartData) {
    return {
        resistanceLevels: [1.0950, 1.0975, 1.1000],
        supportLevels: [1.0900, 1.0880, 1.0850],
        primaryTrend: 'Bullish',
        trendStrength: 75
    };
}

// Generate trading setups (placeholder)
function generateTradingSetups(pyramidData, chartData) {
    const setups = [];
    
    // Example setup based on gauge values
    if (gaugeValues.momentum > 70) {
        setups.push({
            type: 'Momentum Breakout',
            direction: 'long',
            confidence: 75,
            riskReward: '1:2.5',
            stopLoss: '1.0880',
            target: '1.1020'
        });
    }
    
    if (gaugeValues.momentum < 30) {
        setups.push({
            type: 'Momentum Reversal',
            direction: 'short',
            confidence: 65,
            riskReward: '1:2.0',
            stopLoss: '1.0950',
            target: '1.0850'
        });
    }
    
    return setups;
}

// Analyze volume (placeholder)
function analyzeVolume(pyramidData) {
    return {
        trend: 'Increasing',
        vsAverage: '+25%',
        confirmation: 'Strong',
        timeframes: {
            D1: 80,
            H4: 65,
            H1: 45,
            M15: 30
        }
    };
}

// ==================== ENHANCED ANALYSIS DISPLAY ====================

// Update analysis data with confluence calculation
function updateAnalysis(data) {
    if (!data) {
        console.warn("No data provided to update analysis");
        return;
    }
    
    currentAnalysis = data;
    
    // Calculate confluence if we have pyramid data
    if (data.blocks) {
        calculateConfluence(data);
        updateEnhancedAnalysis(data, {});
    }
    
    renderTechnicalSummary(data);
    renderTradingSignals(data);
    renderMarketStructure(data);
    
    // Check for alerts based on confluence
    checkConfluenceAlerts();
}

// Enhanced technical summary with confluence
function renderTechnicalSummary(data) {
    const summaryElement = document.getElementById('technicalSummary');
    if (!summaryElement) return;
    
    if (data.error) {
        summaryElement.innerHTML = `<div class="error">${data.error}</div>`;
        return;
    }
    
    const momentumText = getMomentumText(gaugeValues.momentum);
    const strengthText = getStrengthText(gaugeValues.strength);
    const riskText = getRiskText(gaugeValues.risk);
    
    summaryElement.innerHTML = `
        <div class="summary-content">
            <div class="summary-item">
                <span class="label">Market Confluence:</span>
                <span class="value ${getMomentumClass(gaugeValues.momentum)}">${momentumText}</span>
            </div>
            <div class="summary-item">
                <span class="label">Trend Strength:</span>
                <span class="value ${getStrengthClass(gaugeValues.strength)}">${strengthText}</span>
            </div>
            <div class="summary-item">
                <span class="label">Risk Level:</span>
                <span class="value ${getRiskClass(gaugeValues.risk)}">${riskText}</span>
            </div>
            ${data.technical_summary ? `
            <div class="summary-item">
                <span class="label">Latest Signal:</span>
                <span class="value">${data.technical_summary}</span>
            </div>
            ` : ''}
        </div>
    `;
}

// Render trading signals
function renderTradingSignals(data) {
    const signalsElement = document.getElementById('tradingSignals');
    if (!signalsElement) return;
    
    if (data.error || !data.trading_signals) {
        signalsElement.innerHTML = '<div class="no-signals">No signals available</div>';
        return;
    }
    
    let signalsHTML = '';
    data.trading_signals.forEach((signal, index) => {
        const signalType = getSignalType(signal);
        signalsHTML += `
            <div class="signal-item ${signalType}">
                <div class="signal-icon">${getSignalIcon(signalType)}</div>
                <div class="signal-content">
                    <div class="signal-text">${signal}</div>
                    <div class="signal-meta">${new Date().toLocaleTimeString()}</div>
                </div>
            </div>
        `;
    });
    
    signalsElement.innerHTML = signalsHTML || '<div class="no-signals">No active signals</div>';
}

// Render market structure
function renderMarketStructure(data) {
    const structureElement = document.getElementById('marketStructure');
    if (!structureElement) return;
    
    if (data.error || !data.market_structure) {
        structureElement.innerHTML = '<div class="no-data">Market structure data unavailable</div>';
        return;
    }
    
    structureElement.innerHTML = `
        <div class="structure-content">
            <div class="structure-item">
                <span class="label">Timeframe Analysis:</span>
                <span class="value">${data.market_structure}</span>
            </div>
        </div>
    `;
}

// ==================== ALERT SYSTEM ENHANCEMENTS ====================

// Check for confluence-based alerts
function checkConfluenceAlerts() {
    if (!alertSettings.momentumAlerts) return;
    
    // High momentum alert
    if (gaugeValues.momentum >= 80) {
        createAlert('momentum', `Strong bullish confluence detected (${gaugeValues.momentum}%)`, 'high');
    } else if (gaugeValues.momentum <= -80) {
        createAlert('momentum', `Strong bearish confluence detected (${gaugeValues.momentum}%)`, 'high');
    }
    
    // High volatility alert
    if (gaugeValues.volatility >= 80) {
        createAlert('volatility', `High market volatility detected (${gaugeValues.volatility}%)`, 'medium');
    }
    
    // High risk alert
    if (gaugeValues.risk >= 80) {
        createAlert('risk', `Elevated market risk level (${gaugeValues.risk}%)`, 'high');
    }
}

// ==================== ALERT MANAGEMENT ====================

// Toggle alert setting
function toggleAlertSetting(setting, enabled) {
    alertSettings[setting] = enabled;
    saveAlertSettings();
    console.log(`Alert setting ${setting} ${enabled ? 'enabled' : 'disabled'}`);
}

// Create new alert
function createAlert(type, message, priority = 'medium') {
    const alert = {
        id: generateAlertId(),
        type: type,
        message: message,
        priority: priority,
        time: new Date().toLocaleTimeString(),
        resolved: false
    };
    
    activeAlerts.unshift(alert); // Add to beginning
    if (activeAlerts.length > 50) {
        activeAlerts.pop(); // Keep only last 50 alerts
    }
    
    renderActiveAlerts();
    showAlertNotification(alert);
    
    return alert;
}

// Resolve alert
function resolveAlert(alertId) {
    const alert = activeAlerts.find(a => a.id === alertId);
    if (alert) {
        alert.resolved = true;
        alert.resolvedTime = new Date().toLocaleTimeString();
        renderActiveAlerts();
    }
}

// Clear all alerts
function clearAllAlerts() {
    activeAlerts = [];
    renderActiveAlerts();
}

// Test alert system
function testAlertSystem() {
    createAlert('test', 'This is a test alert - system is working correctly', 'low');
}

// ==================== ALERT CHECKING ====================

// Check for RSI alerts
function checkRSIAlerts(rsiValue) {
    if (!alertSettings.rsiAlerts) return;
    
    if (rsiValue > 70) {
        createAlert('rsi', `RSI Overbought: ${rsiValue.toFixed(1)} - Potential sell signal`, 'high');
    } else if (rsiValue < 30) {
        createAlert('rsi', `RSI Oversold: ${rsiValue.toFixed(1)} - Potential buy signal`, 'high');
    }
}

// Check for price alerts (placeholder)
function checkPriceAlerts(currentPrice, symbol) {
    if (!alertSettings.priceAlerts) return;
    // Implementation would track key price levels
}

// Check for volume alerts (placeholder)
function checkVolumeAlerts(currentVolume, averageVolume) {
    if (!alertSettings.volumeAlerts) return;
    
    if (currentVolume > averageVolume * 2) {
        createAlert('volume', `Volume spike detected: ${(currentVolume/averageVolume).toFixed(1)}x average`, 'medium');
    }
}

// ==================== ALERT RENDERING ====================

// Render alerts sections
function renderAlertsSections() {
    renderActiveAlerts();
    renderAlertSettings();
}

// Render active alerts
function renderActiveAlerts() {
    const alertsElement = document.getElementById('activeAlerts');
    if (!alertsElement) return;
    
    if (activeAlerts.length === 0) {
        alertsElement.innerHTML = `
            <div class="no-alerts">
                <div class="no-alerts-icon">ðŸ”•</div>
                <div class="no-alerts-text">No active alerts</div>
                <div class="no-alerts-subtext">Alerts will appear here when triggered</div>
            </div>
        `;
        return;
    }
    
    let alertsHTML = '';
    activeAlerts.forEach(alert => {
        alertsHTML += `
            <div class="alert-item ${alert.resolved ? 'resolved' : 'active'} ${alert.type}">
                <div class="alert-header">
                    <span class="alert-type">${alert.type}</span>
                    <span class="alert-time">${alert.time}</span>
                </div>
                <div class="alert-message">${alert.message}</div>
                ${!alert.resolved ? `
                    <div class="alert-actions">
                        <button class="alert-btn resolve" onclick="resolveAlert('${alert.id}')">
                            Mark Resolved
                        </button>
                    </div>
                ` : ''}
            </div>
        `;
    });
    
    alertsElement.innerHTML = alertsHTML;
}

// Render alert settings
function renderAlertSettings() {
    const settingsElement = document.getElementById('alertSettings');
    if (!settingsElement) return;
    
    settingsElement.innerHTML = `
        <div class="alert-setting-group">
            <div class="alert-setting-item">
                <input type="checkbox" id="rsiAlert" ${alertSettings.rsiAlerts ? 'checked' : ''} 
                       onchange="toggleAlertSetting('rsiAlerts', this.checked)">
                <label for="rsiAlert">RSI Overbought/Oversold (70/30)</label>
            </div>
            <div class="alert-setting-item">
                <input type="checkbox" id="priceAlert" ${alertSettings.priceAlerts ? 'checked' : ''}
                       onchange="toggleAlertSetting('priceAlerts', this.checked)">
                <label for="priceAlert">Key Price Level Breaks</label>
            </div>
            <div class="alert-setting-item">
                <input type="checkbox" id="volumeAlert" ${alertSettings.volumeAlerts ? 'checked' : ''}
                       onchange="toggleAlertSetting('volumeAlerts', this.checked)">
                <label for="volumeAlert">Volume Spikes (2x Average)</label>
            </div>
            <div class="alert-setting-item">
                <input type="checkbox" id="momentumAlert" ${alertSettings.momentumAlerts ? 'checked' : ''}
                       onchange="toggleAlertSetting('momentumAlerts', this.checked)">
                <label for="momentumAlert">Momentum Shifts</label>
            </div>
        </div>
        <div class="alert-actions-global">
            <button class="alert-btn test" onclick="testAlertSystem()">Test Alert System</button>
            <button class="alert-btn clear" onclick="clearAllAlerts()">Clear All Alerts</button>
        </div>
    `;
}

// ==================== UTILITY FUNCTIONS ====================

// Get signal type from signal text
function getSignalType(signal) {
    if (signal.toLowerCase().includes('buy') || signal.toLowerCase().includes('bullish')) {
        return 'bullish';
    } else if (signal.toLowerCase().includes('sell') || signal.toLowerCase().includes('bearish')) {
        return 'bearish';
    }
    return 'neutral';
}

// Get signal icon
function getSignalIcon(signalType) {
    switch(signalType) {
        case 'bullish': return 'ðŸŸ¢';
        case 'bearish': return 'ðŸ”´';
        default: return 'âšª';
    }
}

// Get momentum description text
function getMomentumText(value) {
    if (value >= 80) return 'Very Bullish';
    if (value >= 50) return 'Bullish';
    if (value >= 20) return 'Slightly Bullish';
    if (value >= -20) return 'Neutral';
    if (value >= -50) return 'Slightly Bearish';
    if (value >= -80) return 'Bearish';
    return 'Very Bearish';
}

// Get strength description text
function getStrengthText(value) {
    if (value >= 80) return 'Very Strong';
    if (value >= 67) return 'Strong';
    if (value >= 45) return 'Moderate';
    if (value >= 33) return 'Weak';
    return 'Very Weak';
}

// Get risk description text
function getRiskText(value) {
    if (value >= 80) return 'Very High';
    if (value >= 67) return 'High';
    if (value >= 45) return 'Medium';
    if (value >= 33) return 'Low';
    return 'Very Low';
}

// Get CSS classes for values
function getMomentumClass(value) {
    if (value >= 50) return 'bullish';
    if (value <= -50) return 'bearish';
    return 'neutral';
}

function getStrengthClass(value) {
    if (value >= 67) return 'strong';
    if (value <= 33) return 'weak';
    return 'moderate';
}

function getRiskClass(value) {
    if (value >= 67) return 'high';
    if (value <= 33) return 'low';
    return 'medium';
}

function getConsensusClass(percent) {
    if (percent >= 80) return 'strong';
    if (percent >= 60) return 'moderate';
    return 'weak';
}

function getConsensusText(percent) {
    if (percent >= 80) return 'Strong Agreement';
    if (percent >= 60) return 'Moderate Agreement';
    return 'Weak Agreement';
}

function getConfidenceClass(confidence) {
    if (confidence >= 80) return 'high';
    if (confidence >= 60) return 'medium';
    return 'low';
}

// Generate unique alert ID
function generateAlertId() {
    return 'alert_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Show alert notification
function showAlertNotification(alert) {
    // Could integrate with browser notifications here
    console.log(`ALERT: ${alert.type} - ${alert.message}`);
}

// Load alert settings from localStorage
function loadAlertSettings() {
    try {
        const saved = localStorage.getItem('megaFlowz_alertSettings');
        if (saved) {
            alertSettings = { ...alertSettings, ...JSON.parse(saved) };
        }
    } catch (e) {
        console.warn('Could not load alert settings:', e);
    }
}

// Save alert settings to localStorage
function saveAlertSettings() {
    try {
        localStorage.setItem('megaFlowz_alertSettings', JSON.stringify(alertSettings));
    } catch (e) {
        console.warn('Could not save alert settings:', e);
    }
}

// Test function to demonstrate gauge functionality
function testGauges() {
    const testValues = {
        momentum: 75,
        volatility: 25,
        strength: 85,
        risk: 65
    };
    updateAllProfessionalGauges(testValues);
}

// Initialize when Analysis tab is opened
function initializeAnalysisTab() {
    const gaugesContainer = document.getElementById('gauges-container');
    if (gaugesContainer && gaugesContainer.getAttribute('data-initialized') !== 'true') {
        initializeAnalysisAlerts();
    }
}

// Export functions for global access
window.analysisAlerts = {
    initialize: initializeAnalysisAlerts,
    updateAnalysis: updateAnalysis,
    calculateConfluence: calculateConfluence,
    createAlert: createAlert,
    resolveAlert: resolveAlert,
    clearAllAlerts: clearAllAlerts,
    checkRSIAlerts: checkRSIAlerts,
    checkPriceAlerts: checkPriceAlerts,
    checkVolumeAlerts: checkVolumeAlerts,
    updateAllProfessionalGauges: updateAllProfessionalGauges,
    testGauges: testGauges,
    initializeAnalysisTab: initializeAnalysisTab
};

// Make functions globally available
window.toggleAlertSetting = toggleAlertSetting;
window.resolveAlert = resolveAlert;
window.clearAllAlerts = clearAllAlerts;
window.testAlertSystem = testAlertSystem;
window.testGauges = testGauges;
window.initializeAnalysisTab = initializeAnalysisTab;

// Auto-initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("ðŸ§  MEGA FLOWZ Analysis & Alerts module loaded");
    // Initialize when Analysis tab is first opened
});